package model

import (
	"context"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

// TestSafeClose проверяет, что safeClose не вызывает панику при повторном закрытии
func TestSafeClose(t *testing.T) {
	ch := make(chan Message, 1)

	// Первое закрытие - должно быть успешным
	safeClose(ch)

	// Второе закрытие - НЕ должно вызывать панику
	safeClose(ch)

	// Третье закрытие nil канала - НЕ должно вызывать панику
	var nilCh chan Message
	safeClose(nilCh)
}

// TestChSendToRxConcurrent проверяет безопасность SendToRx при конкурентном доступе
func TestChSendToRxConcurrent(t *testing.T) {
	ch := Ch{
		RxCh:     make(chan Message, 10),
		UserId:   1,
		DialogId: 100,
		RespName: "TestUser",
	}

	var wg sync.WaitGroup
	var successCount atomic.Int32
	var errorCount atomic.Int32

	// Запускаем 100 горутин, отправляющих сообщения
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			msg := Message{
				Type: "user",
				Content: AssistResponse{
					Message: "Test message",
				},
			}

			if err := ch.SendToRx(msg); err != nil {
				errorCount.Add(1)
			} else {
				successCount.Add(1)
			}
		}(i)
	}

	// Через 10ms закрываем канал
	time.Sleep(10 * time.Millisecond)
	ch.Close()

	wg.Wait()

	t.Logf("Success: %d, Errors: %d", successCount.Load(), errorCount.Load())

	// Проверяем, что не было паники
	if successCount.Load()+errorCount.Load() != 100 {
		t.Errorf("Expected 100 operations, got %d", successCount.Load()+errorCount.Load())
	}
}

// TestChCloseWhileSending проверяет отправку в закрываемый канал
func TestChCloseWhileSending(t *testing.T) {
	ch := Ch{
		RxCh:     make(chan Message, 1),
		UserId:   1,
		DialogId: 100,
		RespName: "TestUser",
	}

	var wg sync.WaitGroup
	panicCount := atomic.Int32{}

	// Горутина отправляет сообщения
	wg.Add(1)
	go func() {
		defer wg.Done()
		defer func() {
			if r := recover(); r != nil {
				panicCount.Add(1)
				t.Errorf("Паника не должна происходить: %v", r)
			}
		}()

		for i := 0; i < 1000; i++ {
			msg := Message{Type: "user"}
			_ = ch.SendToRx(msg)
			time.Sleep(time.Microsecond)
		}
	}()

	// Горутина закрывает канал
	wg.Add(1)
	go func() {
		defer wg.Done()
		time.Sleep(5 * time.Millisecond)
		ch.Close()
	}()

	wg.Wait()

	if panicCount.Load() > 0 {
		t.Errorf("Обнаружено %d паник", panicCount.Load())
	}
}

// TestChIsOpenFlags проверяет корректность флагов открытия/закрытия
func TestChIsOpenFlags(t *testing.T) {
	ch := Ch{
		RxCh:     make(chan Message, 1),
		TxCh:     make(chan Message, 1),
		UserId:   1,
		DialogId: 100,
		RespName: "TestUser",
	}

	// Изначально каналы открыты
	if !ch.IsRxOpen() {
		t.Error("RxCh должен быть открыт")
	}
	if !ch.IsTxOpen() {
		t.Error("TxCh должен быть открыт")
	}

	// Закрываем
	ch.Close()

	// После закрытия флаги должны быть установлены
	if ch.IsRxOpen() {
		t.Error("RxCh должен быть закрыт")
	}
	if ch.IsTxOpen() {
		t.Error("TxCh должен быть закрыт")
	}

	// Попытка отправки должна вернуть ошибку
	msg := Message{Type: "user"}
	if err := ch.SendToRx(msg); err == nil {
		t.Error("Отправка в закрытый канал должна вернуть ошибку")
	}
}

// TestRaceConditionMultipleDialogs проверяет race condition при множественных диалогах
func TestRaceConditionMultipleDialogs(t *testing.T) {
	m := &Models{
		ctx:        context.Background(),
		responders: sync.Map{},
	}

	var wg sync.WaitGroup
	dialogCount := 10

	// Создаем несколько диалогов параллельно
	for i := 0; i < dialogCount; i++ {
		wg.Add(1)
		go func(dialogId uint64) {
			defer wg.Done()

			// Создаем респондера
			user := &RespModel{
				Chan: make(map[uint64]Ch),
			}

			user.Chan[dialogId] = Ch{
				RxCh:     make(chan Message, 1),
				TxCh:     make(chan Message, 1),
				UserId:   uint32(dialogId),
				DialogId: dialogId,
			}

			m.responders.Store(dialogId, user)

			// Отправляем несколько сообщений
			for j := 0; j < 10; j++ {
				msg := Message{Type: "user"}
				ch := user.Chan[dialogId]
				_ = ch.SendToRx(msg)
			}

			// Закрываем диалог
			time.Sleep(5 * time.Millisecond)
			m.CleanDialogData(dialogId)
		}(uint64(i))
	}

	wg.Wait()

	// Проверяем, что все диалоги удалены
	count := 0
	m.responders.Range(func(key, value interface{}) bool {
		count++
		return true
	})

	if count != 0 {
		t.Errorf("Ожидалось 0 диалогов, найдено %d", count)
	}
}

// BenchmarkChSendToRx измеряет производительность безопасной отправки
func BenchmarkChSendToRx(b *testing.B) {
	ch := Ch{
		RxCh:     make(chan Message, 100),
		UserId:   1,
		DialogId: 100,
		RespName: "BenchUser",
	}

	// Горутина для чтения сообщений
	go func() {
		for range ch.RxCh {
			// Просто читаем и отбрасываем
		}
	}()

	msg := Message{
		Type: "user",
		Content: AssistResponse{
			Message: "Benchmark message",
		},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = ch.SendToRx(msg)
	}

	ch.Close()
}

// BenchmarkDirectChannelSend измеряет производительность прямой отправки (для сравнения)
func BenchmarkDirectChannelSend(b *testing.B) {
	ch := make(chan Message, 100)

	// Горутина для чтения сообщений
	go func() {
		for range ch {
			// Просто читаем и отбрасываем
		}
	}()

	msg := Message{
		Type: "user",
		Content: AssistResponse{
			Message: "Benchmark message",
		},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ch <- msg
	}

	close(ch)
}

// TestGracefulShutdownWithActiveDialogs проверяет корректное завершение при активных диалогах
func TestGracefulShutdownWithActiveDialogs(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	m := &Models{
		ctx:        ctx,
		cancel:     cancel,
		responders: sync.Map{},
	}

	// Создаем несколько активных диалогов
	for i := uint64(1); i <= 5; i++ {
		user := &RespModel{
			Chan:   make(map[uint64]Ch),
			Cancel: func() {},
		}

		user.Chan[i] = Ch{
			RxCh:     make(chan Message, 10),
			TxCh:     make(chan Message, 10),
			UserId:   uint32(i),
			DialogId: i,
		}

		m.responders.Store(i, user)

		// Запускаем горутину, отправляющую сообщения
		go func(dialogId uint64) {
			for j := 0; j < 100; j++ {
				select {
				case <-ctx.Done():
					return
				default:
					ch := user.Chan[dialogId]
					msg := Message{Type: "user"}
					_ = ch.SendToRx(msg)
					time.Sleep(time.Millisecond)
				}
			}
		}(i)
	}

	// Даем время для отправки нескольких сообщений
	time.Sleep(50 * time.Millisecond)

	// Вызываем Shutdown
	m.Shutdown()

	// Проверяем, что все каналы закрыты
	m.responders.Range(func(key, value interface{}) bool {
		t.Error("После Shutdown не должно остаться респондеров")
		return false
	})
}
